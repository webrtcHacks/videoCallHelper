<!DOCTYPE html>
<html>
<head>
    <title>Adjustable Frame Rate Video Stream</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }

        div.vid {
            width: 45%; /* Adjust size as needed */
            margin: 10px;
            border: 1px solid #ccc;
        }

        video {
            width: 100%;
            display: block;
        }

        #controls {
            width: 80%;
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }

        label, input {
            margin: 5px;
        }
    </style>
</head>
<body>
<div id="controls">
    <button id="toggleButton">Enable Manipulation</button>
    <button id="recordButton">Start Recording</button>
    <button id="playbackButton" disabled>Playback Recording</button>
    <br>
    <label>Resolution Scale Factor (%): <input type="range" id="resolutionSlider" min="10" max="100"
                                               value="100"></label>
    <label>Frame Rate Reduction (%): <input type="range" id="rateReductionSlider" min="0" max="100" value="50"></label>
    <label>Drop Probability: <input type="range" id="dropProbSlider" min="0" max="100" value="30"></label>
    <label>Latency (ms): <input type="range" id="latencySlider" min="0" max="1000" value="300"></label>
</div>
<div class="vid">
    <h2>Original Video</h2>
    <video id="inputVideo" controls autoplay muted></video>
    <div id="inputVideoInfo"></div>
</div>
<div class="vid">
    <h2>Manipulated Video</h2>
    <video id="outputVideo" controls autoplay></video>
    <div id="outputVideoInfo"></div>
</div>

<script>

    const inputVideo = document.getElementById('inputVideo');
    const outputVideo = document.getElementById('outputVideo');
    const toggleButton = document.getElementById('toggleButton');
    const recordButton = document.getElementById('recordButton');
    const playbackButton = document.getElementById('playbackButton');
    const resolutionSlider = document.getElementById('resolutionSlider');
    const rateReductionSlider = document.getElementById('rateReductionSlider');
    const dropProbSlider = document.getElementById('dropProbSlider');
    const latencySlider = document.getElementById('latencySlider');

    let manipulateFrames = false;
    let frameRate;
    let frameInterval;

    let workers = [];

    const constraints = {video: false, audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false}};

    navigator.mediaDevices.getUserMedia(constraints)
        .then(async stream => {
            inputVideo.srcObject = stream;
            window.sourceStream = stream;

            /*
            const settings = track.getSettings();
            frameRate = settings.frameRate;
            frameInterval = 1000 / frameRate;

            // Display the video track settings
            const inputVideoInfo = document.getElementById('inputVideoInfo');
            inputVideoInfo.textContent = `Resolution: ${settings.width}x${settings.height}, Frame rate: ${settings.frameRate}`;
             */

            const generators = [];

            stream.getTracks().forEach(track=>{
                const kind = track.kind;
                const processor = new MediaStreamTrackProcessor({track});
                const generator = new MediaStreamTrackGenerator({kind});
                generators.push(generator);

                const reader = processor.readable;
                const writer = generator.writable;

                const worker = new Worker('impairmentWorker.js', {name: `${kind}-impairment`});
                worker.postMessage({command: 'setup', reader, writer, kind}, [reader, writer]);
                workers.push(worker);
            });

            outputVideo.srcObject = new MediaStream(generators);
            window.outputStream = outputVideo.srcObject;



        })
        .catch(error => {
            console.error('Error accessing media devices.', error);
        });

    /*
    async function processFrame(frame) {

        if (!manipulateFrames) {
            lastFrame?.close();
            lastFrame = frame.clone();
            // await writer.write(frame);
            return frame;
        } else {
            // Add latency
            await new Promise(resolve => setTimeout(resolve, latency));

            // Simulate dropped frames by repeating the last frame
            if (Math.random() < dropProbability) {
                if (lastFrame) {
                    //await writer.write(lastFrame.clone());
                    frame.close();
                    return lastFrame.clone();
                }
            } else {
                // adjust resolution
                // Scale down then scale up to original size
                const originalWidth = frame.displayWidth;
                const originalHeight = frame.displayHeight;
                const scaledDownWidth = Math.floor(originalWidth * resolutionScaleFactor);
                const scaledDownHeight = Math.floor(originalHeight * resolutionScaleFactor);
                const canvas = new OffscreenCanvas(scaledDownWidth, scaledDownHeight);
                const ctx = canvas.getContext('2d');
                ctx.drawImage(frame, 0, 0, scaledDownWidth, scaledDownHeight);

                const scaledUpCanvas = new OffscreenCanvas(originalWidth, originalHeight);
                const scaledCtx = scaledUpCanvas.getContext('2d');
                scaledCtx.drawImage(canvas, 0, 0, originalWidth, originalHeight);
                const scaledFrame = new VideoFrame(scaledUpCanvas, {timestamp: frame.timestamp});
                frame.close();

                lastFrame?.close();
                lastFrame = scaledFrame.clone();
                // await writer.write(scaledFrame);
                return scaledFrame;
            }
        }
    }
     */


    // Setup controls
    [resolutionSlider, rateReductionSlider, dropProbSlider, latencySlider].forEach(slider => {
        slider.addEventListener('input', () => {
            console.log(`"${slider.id}" changed to ${slider.value}`);
            workers.forEach(worker=>worker.postMessage({
                command: 'config',
                config: {
                    resolutionScaleFactor: parseInt(resolutionSlider.value) / 100,
                    effectiveFrameRate: frameRate * (1 - parseInt(rateReductionSlider.value) / 100),
                    dropProbability: parseInt(dropProbSlider.value) / 100,
                    latency: parseInt(latencySlider.value)
                }
            }));
        });
    });

    toggleButton.addEventListener('click', () => {
        manipulateFrames = !manipulateFrames;
        toggleButton.textContent = manipulateFrames ? 'Disable Manipulation' : 'Enable Manipulation';
        workers.forEach(worker=>worker.postMessage({command: manipulateFrames ? 'start' : 'stop'}));
    });

    /** Recording and playback **/

    let mediaRecorder;
    let recordedBlobs;

    recordButton.addEventListener('click', () => {
        if (recordButton.textContent === 'Start Recording') {
            startRecording();
        } else {
            stopRecording();
            recordButton.textContent = 'Start Recording';
            playbackButton.disabled = false;
        }
    });

    playbackButton.addEventListener('click', () => {
        const superBuffer = new Blob(recordedBlobs, {type: 'video/webm'});
        outputVideo.src = null;
        outputVideo.srcObject = null;
        outputVideo.src = window.URL.createObjectURL(superBuffer);
        outputVideo.controls = true;
        outputVideo.play();
    });

    function startRecording() {
        recordedBlobs = [];
        let options = {mimeType: 'video/webm;codecs=vp9,opus'};
        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
            console.error(`${options.mimeType} is not supported`);
            options = {mimeType: 'video/webm;codecs=vp8,opus'};
            if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                console.error(`${options.mimeType} is not supported`);
                options = {mimeType: 'video/webm'};
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    console.error(`${options.mimeType} is not supported`);
                    options = {mimeType: ''};
                }
            }
        }

        try {
            mediaRecorder = new MediaRecorder(window.outputStream, {mimeType: ""});
        } catch (e) {
            console.error('Exception while creating MediaRecorder:', e);
            return;
        }

        recordButton.textContent = 'Stop Recording';
        playbackButton.disabled = true;
        mediaRecorder.onstop = (event) => {
            console.log('Recorder stopped: ', event);
        };
        mediaRecorder.ondataavailable = handleDataAvailable;
        mediaRecorder.start();
        console.log('MediaRecorder started', mediaRecorder);
    }

    function stopRecording() {
        mediaRecorder.stop();
    }

    function handleDataAvailable(event) {
        if (event.data && event.data.size > 0) {
            recordedBlobs.push(event.data);
        }
    }


</script>
</body>
</html>
