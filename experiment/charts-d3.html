<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>My speech</title>
    <!--script src="https://cdn.plot.ly/plotly-2.4.1.min.js"></script-->
    <script src="http://d3js.org/d3.v3.js"></script>
    <!--script src="//unpkg.com/timelines-chart"></script-->
    <script src="timeline.js"></script>
    <style>
        table {
            border: 1px solid;
        }

        div#chart {
            width: 80%;
            height: 300px;
            margin: auto;
        }
    </style>
</head>
<body>
<div id="chart" style=""></div>
<span id="output"></span>

<script src="events.json" type="application/json"></script>
<script>
    const localLevels = [];
    const remoteLevels = [];
    const trackEvents = [];
    let dupeCount = 0;

    /*
     *  Plotly setup
     */

    const chart = document.getElementById('chart');

    let localLevelsSeries = {
        x: [],
        y: [],
        type: 'histogram',
        name: 'local',
        opacity: 0.5,
        histfunc: "sum",
        autobinx: true,
    };

    let remoteLevelsSeries = {
        x: [],
        y: [],
        type: 'histogram',
        name: 'remote',
        opacity: 0.5,
        histfunc: "sum",
        autobinx: true

    };


    let layout = {
        grid: {rows: 2, columns: 1, pattern: 'independent'},
        xaxis: {
            autorange: true,
            fixedrange: false,
            showgrid: true,
            type: 'time'
        },
        yaxis: {
            autorange: true,
            showgrid: true,
            title: 'AudioLevels',
            range: [0],

        },
        barmode: 'overlay',
        margin: {t: 0}
    };


    async function main() {
        const response = await fetch("events.json");
        const events = await response.json();
        console.log("all", events.length);

        let lastEvent = {message: null, ts: null, data: null};
        events.forEach(event => {
            // Dedupe the same
            const lastEventDelta = Math.abs(event.ts - lastEvent.ts);
            const dataTheSame = JSON.stringify(event.data) === JSON.stringify(lastEvent.data);
            const dupe = event.message === lastEvent.message && dataTheSame && lastEventDelta < 100;
            lastEvent = event;
            if (dupe) {
                //console.log("repeat", lastEventDelta, event);
                dupeCount++;
                return
            }

            const datetime = new Date(event.ts).toLocaleTimeString();
            if (event.message === 'local_audio_level') {
                const audioLevelData = {timeString: datetime, ts: event.ts, level: event.data.audioLevel};
                localLevels.push(audioLevelData)
                // console.log(datetime, event.message, event.data.audioLevel)
            } else if (event.message === 'remote_audio_level') {
                const audioLevelData = {
                    timeString: datetime,
                    ts: event.ts,
                    level: event.data.audioLevel,
                    source: event.data.source
                };
                remoteLevels.push(audioLevelData)
                // console.log(datetime, event.message, event.data.audioLevel)
            } else {
                const eventData = {
                    timeString: datetime,
                    ts: event.ts,
                    message: event.message,
                    kind: event.data.kind || event.data?.trackData?.kind || null,
                    id: event.data.id || event.data?.trackData?.id || null
                }
                trackEvents.push(eventData)
            }
        });

        console.log("dupes", dupeCount);

        const localTimes = localLevels
            .filter((el, idx, arr) => arr[idx - 1] && el.timeString !== arr[idx - 1].timeString)
            .map(el => el.timeString);

        // ToDo: needs calibration
        const MIN_THRESHOLD = 0.05;
        const localValues = localLevels.map(e => e.level);
        const localThreshold = Math.max(...localValues) * MIN_THRESHOLD;

        // const localDisplayValues = localValues.map(level=>level>localThreshold);
        // console.log(localDisplayValues);

        // ToDo: turn this all into a class if it works

        const localSpeakingIntervals = [];
        let lastSampleSpeaking = false;
        let sampleCount = 0;
        let lastStart = {};
        localLevels.forEach(value => {
            // console.log(value);

            const {timeString, ts, level} = value;

            // console.log(timeString, level >= localThreshold);
            if (level >= localThreshold) {
                // console.log("speaking");
                sampleCount++;
                if (!lastSampleSpeaking) {
                    lastStart = value;
                }
                lastSampleSpeaking = true;

            } else if (level < localThreshold) {
                if (lastSampleSpeaking && sampleCount > 1) {
                    const interval = {
                        start: lastStart,
                        stop: value,
                        sampleCount: sampleCount
                    }

                    localSpeakingIntervals.push(interval);
                    console.log("start:", lastStart.timeString)
                    console.log("stop:", timeString)
                }
                sampleCount = 0;
                lastSampleSpeaking = false;
            }

        });

        // https://codepen.io/manglass/pen/MvLBRz

        console.log(JSON.stringify(localSpeakingIntervals));


        /*
        const times = localSpeakingIntervals.map(e => {
            return {
                "starting_time": e.start.ts,
                "ending_time": e.stop.ts

            }
        });

         */

        const testData = [
            {
                times: [
                    { starting_time: 1355752800000, ending_time: 1355759900000 },
                    { starting_time: 1355767900000, ending_time: 1355774400000 }
                ]
            },
            { times: [{ starting_time: 1355759910000, ending_time: 1355761900000 }] },
            { times: [{ starting_time: 1355761910000, ending_time: 1355763910000 }] }
        ];

        // console.log(testData);
        console.log([{times}]);

        const myChart = d3.timeline()
            .rotateTicks(45)
            .relativeTime()
            .tickFormat({
                format: function (d) {
                    return d3.time.format("%H:%M:%S")(d);
                },
                tickTime: d3.time.seconds,
                tickInterval: 15,
                tickSize: 15
            });

        const svg = d3.select("#chart")
            .append("svg")
            .attr("width", 1000)
            .datum([{times}])
            // .datum(testData)
            .call(myChart);

    }

    main();

</script>
</body>
</html>
