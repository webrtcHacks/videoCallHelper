<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Stream Example</title>
    <style>
        body {
            background-color: #333;
            color: #fff;
        }
    </style>
</head>
<body>
<video id="videoElement" autoplay playsinline controls></video>
<br>
<button id="camera">Get Camera</button>
<button id="bbbButton">Play BigBuckBunny</button>
<button id="startGenerator" disabled>Start Generator</button>
<br>
<button id="recordButton">Record</button>
<button id="playButton">Play Recorded</button>
<button id="insertButton" disabled>Insert</button>

<script>
    const video = document.getElementById('videoElement');
    const cameraButton = document.getElementById('camera');
    const bbbButton = document.getElementById('bbbButton');
    const startGeneratorButton = document.getElementById('startGenerator');
    const recordButton = document.getElementById('recordButton');
    const playButton = document.getElementById('playButton');
    const insertButton = document.getElementById('insertButton');

    let stream;
    let mediaRecorder;
    let recordedChunks = [];
    let generator;
    let pipeController;

    // Start the getUserMedia stream
    async function startUserMedia() {
        try {
            stream = await navigator.mediaDevices.getUserMedia({ video: true });
            videoElement.srcObject = stream;
            startGeneratorButton.disabled = false;
        } catch (error) {
            console.error('Error accessing media devices.', error);
        }
    }

    function startRecording() {
        recordedChunks = [];
        mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs="vp8"' });

        mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
                recordedChunks.push(event.data);
            }
        };

        mediaRecorder.start(1000);
    }

    async function startWorker(arrayBuffer) {
        const worker = new Worker('mse-worker.js', {name: "videoPlayer"});

        // Send data to worker after a brief delay to ensure worker initialization
        setTimeout(() => {
            worker.postMessage({ type: 'playback', data: arrayBuffer });
        }, 500);

        return new Promise((resolve, reject) => {
            worker.addEventListener("message", (msg) => {
                if (msg.data.type === 'sourceOpen') {
                    console.log('message', msg);
                    resolve(msg.data.sourceHandle);
                }
            });
        });
    }

    cameraButton.onclick = () => {
        startUserMedia();
    };


    recordButton.onclick = () => {
        if (recordButton.textContent === 'Record') {
            startRecording();
            recordButton.textContent = 'Stop Recording';
        } else {
            mediaRecorder.stop();
            console.log(`Recorded Blobs: ${recordedChunks.length}`);
            recordButton.textContent = 'Record';
        }
    };

    playButton.onclick = () => {
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        blob.arrayBuffer().then(async arrayBuffer => {
            console.log('ArrayBuffer size:', arrayBuffer.byteLength);
            // video.srcObject = await startWorker(arrayBuffer);
            const handle = await startWorker(arrayBuffer);
            video.src = URL.createObjectURL(mediaSource);
            video.play();
        });
    };


    // Replace the getUserMedia stream with BigBuckBunny.mp4
    bbbButton.onclick = async ()=> {
        // Stop the existing stream
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
        }
        const assetURL = 'frag_bunny_10s.webm';
        const response = await fetch(assetURL);
        const arrayBuffer = await response.arrayBuffer();
        video.srcObject = await startWorker(arrayBuffer);
        video.play();
    };

    startGeneratorButton.onclick = async () => {
        if (pipeController) {
            pipeController.abort(); // Abort the previous pipe operation
        }
        pipeController = new AbortController(); // Create a new controller for the new pipe operation

        generator = new MediaStreamTrackGenerator({ kind: 'video' });
        video.srcObject = new MediaStream([generator]);
        insertButton.disabled = false;

        const processor = new MediaStreamTrackProcessor(stream.getVideoTracks()[0]);
        await processor.readable.pipeTo(generator.writable, { signal: pipeController.signal }).catch(e => {
            if (e.name !== 'AbortError') {
                console.error('Error piping to generator:', e);
            }
        });
        console.log("original generator started");
    };


    // piping to the new generator isn't working
    // also hiddenVideo.captureStream() only works when the video is visible
    insertButton.onclick = async () => {

        console.log("inserting video");


        pipeController?.abort(); // Abort the previous pipe operation
        pipeController = new AbortController(); // Create a new controller for the new pipe operation


        const hiddenVideo = document.createElement('video');
        window.hiddenVideo = hiddenVideo;

        // hiddenVideo.style.display = 'none';
        hiddenVideo.autoplay = true;
        hiddenVideo.muted = true; // Mute to autoplay without user interaction
        hiddenVideo.loop = true;
        hiddenVideo.src = 'frag_bunny_10s.webm';
        document.body.appendChild(hiddenVideo);

        // video.play();


        hiddenVideo.oncanplay = async () => {
            console.log("videoElement can play");
            const videoStream = hiddenVideo.captureStream();
            const videoTrack = videoStream.getVideoTracks()[0];
            console.log("videoTrack:", videoTrack);


            const processor = new MediaStreamTrackProcessor({ track: videoTrack });

            await processor.readable.pipeTo(generator.writable, { signal: pipeController.signal }).catch(e => {
                if (e.name !== 'AbortError') {
                    console.error('Error piping to generator:', e);
                }
            });

            // video.srcObject = new MediaStream([videoTrack]);
        };

    };

    // Start the getUserMedia stream
    // startUserMedia();
</script>
</body>
</html>
