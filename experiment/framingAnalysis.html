<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebCam Framing Analysis Experiment</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <style>
        div#one_to_three{
            height: 480px;
        }
        div#sixteen_to_nine{
            height: 720px;
        }
        img {
            position: absolute;
            opacity: 0.2;
        }
        img.temp{
            position: relative;
        }
        canvas{
            position: absolute;
            height: 480px;
            width: 640px;
            z-index: 100;
        }

    </style>
</head>
<body>
<button id="start">Start</button>
<button id="stop">Stop</button>

<img id="temp_img" class="temp" hidden>

<h2>Images</h2>
<div id="images">
    <h3>1:3 Aspect Ratio</h3>
    <div id="one_to_three" class="overlap">
        <canvas></canvas>

    </div>
    <h3>16:9 Aspect Ratio</h3>
    <div id="sixteen_to_nine" class="overlap">
    </div>
    <h3>Other Aspect Ratios</h3>
    <div id="other_ratio" class="overlap">
    </div>
</div>
<div id="results">
</div>


<script type="module">
    // import {FaceMesh} from '/node_modules/@mediapipe/face_mesh/face_mesh.js';
    // import {FaceMesh} from '../node_modules/@mediapipe/face_mesh';
    // import {entries} from '../node_modules/idb-keyval/dist/index.js';
    // import {entries} from "idb-keyval";

    const startBtn = document.querySelector('button#start');
    const stopBtn = document.querySelector('button#stop');

    const results = document.querySelector('div#results');
    // const rowDiv = document.querySelector('div#images');
    const oneThreeDiv = document.querySelector('div#one_to_three');
    const sixteenNineDiv = document.querySelector('div#sixteen_to_nine');
    const otherRatioDiv = document.querySelector('div#other_ratio');
    const canvasElem = document.querySelector('canvas');
    const ctx = canvasElem.getContext("2d");


    const tmpImg = document.querySelector('img#temp_img');
    let stop = false;

    function drawPoint(x,y){
        const scaled_x = (x*canvasElem.width);
        const scaled_y = (y*canvasElem.height);

        // console.log(scaled_x, scaled_y);

        // ctx.strokeStyle = 'rgba(0, 250, 0, 1)';
        ctx.beginPath();
        // ctx.arc(scaled_x, scaled_y, 5, 0, 2 * Math.PI);
        ctx.arc(scaled_x, scaled_y, 1, 0, 2 * Math.PI);
        // ctx.stroke();
        ctx.fill();
    }

    canvasElem.width = 640;
    canvasElem.height = 480;
    // console.log(`canvas size: ${canvasElem.width}x${canvasElem.height}`);
    // drawPoints(0.5, 0.5);

    // crosshair
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(200, 0, 0, 0.5)';
    ctx.setLineDash([1, 1]);
    ctx.beginPath();
    ctx.moveTo(canvasElem.width/2, 0);
    ctx.lineTo(canvasElem.width/2, canvasElem.height);
    ctx.stroke();
    ctx.moveTo(0, canvasElem.height/3);
    ctx.lineTo(canvasElem.width, canvasElem.height/3);
    ctx.stroke();
    ctx.setLineDash([]);



    const faceMesh = new FaceMesh({
        locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
        }
    });

    await faceMesh.initialize();

    /*const faceMesh = new FaceMesh({locateFile: (file) => {
        return `../face_mesh/${file}`;
      }});

     */

    faceMesh.setOptions({
        maxNumFaces: 1,
        refineLandmarks: false,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    faceMesh.onResults(results => {
        // console.log("faceMesh result:", results)
        ctx.save();

        // canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        // ctx.drawImage(results.image, 0, 0, canvasElem.width, canvasElem.height, );
        if (results.multiFaceLandmarks) {
            for (const landmarks of results.multiFaceLandmarks) {

                // console.log(landmarks[168]);
                const {x,y,z} = landmarks[6];
                ctx.lineWidth = 1;
                ctx.fillStyle = 'rgba(0, 240, 0, 1)';
                drawPoint(x,y);
                // console.log(x*640,y*480,z*640);


                // drawConnectors(ctx, landmarks, FACEMESH_TESSELATION, {color: '#C0C0C070', lineWidth: 1});
                // drawConnectors(ctx, landmarks, FACEMESH_RIGHT_EYE, {color: '#FF3030'});
                // drawConnectors(ctx, landmarks, FACEMESH_RIGHT_EYEBROW, {color: '#FF3030'});
                // drawConnectors(ctx, landmarks, FACEMESH_RIGHT_IRIS, {color: '#FF3030'});
                // drawConnectors(ctx, landmarks, FACEMESH_LEFT_EYE, {color: '#30FF30'});
                // drawConnectors(ctx, landmarks, FACEMESH_LEFT_EYEBROW, {color: '#30FF30'});
                // drawConnectors(ctx, landmarks, FACEMESH_LEFT_IRIS, {color: '#30FF30'});
                // drawConnectors(ctx, landmarks, FACEMESH_FACE_OVAL, {color: '#E0E0E0'});
                // drawConnectors(ctx, landmarks, FACEMESH_LIPS, {color: '#E0E0E0'});

                // drawConnectors(ctx, landmarks, FACEMESH_FACE_OVAL, {color: '#FF3030', lineWidth: 1});

                /*
                const [midwayBetweenEyes] = results.multiFaceLandmarks.annotations.midwayBetweenEyes
                const x = midwayBetweenEyes[0];
                const y = midwayBetweenEyes[1];
                ctx.strokeStyle = 'rgba(200, 0, 0, 0.5)';
                ctx.setLineDash([1, 1]);
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(x, y , 10, 0, 2*Math.PI)
                ctx.stroke();
                ctx.lineWidth = 1;
                ctx.setLineDash([]);
                 */

                /*
                for(const points in landmarks){
                    console.log(landmarks[points]);
                    const {x,y} = landmarks[points];
                    drawPoint(x,y);
                }

                drawPoint(0.5, 0.5);

                 */



            }
        }
        ctx.restore();
    });

    stopBtn.onclick = ()=> {
        console.log("stopping");
        startBtn.enabled = false;
        stopBtn.enabled = false;
        stop = true;
    }

    startBtn.onclick = async () => {

        const parentDirectoryHandle = await window.showDirectoryPicker();
        // In that existing directory, create a new directory
        const directoryHandle = await parentDirectoryHandle.getDirectoryHandle('vch_images', {
            create: false,
        });
        console.log(`directory handle "${directoryHandle.name}" under "${parentDirectoryHandle.name}"`);

        let count = 0;

        // const offscreenCanvas = new OffscreenCanvas(1,1)

        for await (const [name, handle] of directoryHandle.entries()) {

            // if (count > 20) break;

            // console.log({ name, handle })
            const file = await handle.getFile();
            // console.log(file);

            // Check if the file is an image.
            if (file.type && !file.type.startsWith('image/')) {
                console.log('File is not an image.', file.type, file);
                return;
            }

            const reader = new FileReader();
            reader.addEventListener('load', async (event) => {
                count++;

                const imgData = event.target.result;
                // tmpImg.src = imgData;
                // await tmpImg;

                const img = new Image();
                img.src = imgData;

                try{
                    await img.decode();
                    const aspectRatio = (img.naturalWidth / img.naturalHeight).toFixed(1);
                    console.log(`${img.naturalWidth}wx${img.naturalHeight}h; ${aspectRatio}`)

                    if (aspectRatio === "1.3"){
                        oneThreeDiv.appendChild(img);
                        await new Promise(resolve => setTimeout(resolve, 10));
                        await faceMesh.send({image: img});
                    }
                    /*else if (aspectRatio === "1.8")
                        sixteenNineDiv.appendChild(img);
                    else
                        otherRatioDiv.appendChild(img);

                     */
                }
                catch(err){
                    console.error(err);
                    stop = true;
                }


            });
            await reader.readAsDataURL(file);
            if(stop) break;

        }
    }


</script>
</body>
</html>
