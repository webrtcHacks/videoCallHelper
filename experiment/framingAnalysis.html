<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebCam Framing Analysis Experiment</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
            crossorigin="anonymous"></script>
    <style>
        div#four_to_three {
            height: 480px;
            width: 640px;
        }

        div#sixteen_to_nine {
            height: 720px;
            width: 1280px;
        }

        div#other_ratio {
            height: 300px;
            width: 300px;
        }

        img {
            position: absolute;
            opacity: 0.2;
            object-fit: contain;
        }

        img.temp {
            position: relative;
        }

        canvas {
            position: absolute;
            z-index: 100;
            background-color: black;
        }

    </style>
</head>
<body>
<button id="start">Start</button>
<button id="stop">Stop</button>

<img id="temp_img" class="temp" hidden>

<h2>Images</h2>
<div id="images">
    <p>Images processed: <span id="count">0</span></p>
    <h3>4:3 Aspect Ratio</h3>
    <div id="four_to_three" class="overlap">
        <canvas width="640" height="480"></canvas>

    </div>
    <h3>16:9 Aspect Ratio</h3>
    <div id="sixteen_to_nine" class="overlap">
        <canvas width="1280" height="720"></canvas>
    </div>
    <h3>Other Aspect Ratios</h3>
    <div id="other_ratio" class="overlap">
        <canvas height="300"></canvas>
    </div>
</div>
<div id="results">
</div>


<script type="module">
    // import {FaceMesh} from '/node_modules/@mediapipe/face_mesh/face_mesh.js';
    // import {FaceMesh} from '../node_modules/@mediapipe/face_mesh';
    // import {entries} from '../node_modules/idb-keyval/dist/index.js';
    // import {entries} from "idb-keyval";

    const startBtn = document.querySelector('button#start');
    const stopBtn = document.querySelector('button#stop');

    const results = document.querySelector('div#results');
    const countSpan = document.querySelector('span#count');

    const oneThreeDiv = document.querySelector('div#four_to_three');
    const sixteenNineDiv = document.querySelector('div#sixteen_to_nine');
    const otherRatioDiv = document.querySelector('div#other_ratio');

    /*
    const canvasOneThree = document.querySelector('div#four_to_three>canvas');
    const canvasSixteenNine = document.querySelector('div#sixteen_to_nine>canvas');
    const canvasOther = document.querySelector('div#other_ratio>canvas');
     */


    // const ctx = canvasElem.getContext("2d");


    const tmpImg = document.querySelector('img#temp_img');
    let stop = false;

    function drawPoint(ctx, x, y) {
        const scaled_x = (x * ctx.canvas.width);
        const scaled_y = (y * ctx.canvas.height);

        // console.log(scaled_x, scaled_y);

        // ctx.strokeStyle = 'rgba(0, 250, 0, 1)';
        ctx.beginPath();
        // ctx.arc(scaled_x, scaled_y, 5, 0, 2 * Math.PI);
        ctx.arc(scaled_x, scaled_y, 1, 0, 2 * Math.PI);
        // ctx.stroke();
        ctx.fill();
    }

    // setup canvases, return context
    function setupCanvas(canvasSelector) {
        const canvasElem = document.querySelector(canvasSelector);
        const ctx = canvasElem.getContext("2d");

        // console.log(`canvas size: ${canvasElem.width}x${canvasElem.height}`);

        // crosshair
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'rgba(200, 0, 0, 0.5)';
        ctx.setLineDash([1, 1]);
        ctx.beginPath();
        ctx.moveTo(canvasElem.width / 2, 0);
        ctx.lineTo(canvasElem.width / 2, canvasElem.height);
        ctx.stroke();
        ctx.moveTo(0, canvasElem.height / 3);
        ctx.lineTo(canvasElem.width, canvasElem.height / 3);
        ctx.stroke();
        ctx.setLineDash([]);

        return ctx
    }

    const fourThreeCtx = setupCanvas('div#four_to_three>canvas');
    const sixteenNine = setupCanvas('div#sixteen_to_nine>canvas');


    const faceMesh = new FaceMesh({
        locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
        }
    });

    await faceMesh.initialize();

    /*const faceMesh = new FaceMesh({locateFile: (file) => {
        return `../face_mesh/${file}`;
      }});

     */

    faceMesh.setOptions({
        maxNumFaces: 1,
        refineLandmarks: true,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    faceMesh.onResults(results => {
        // console.log("faceMesh result:", results)

        const aspectRatio = (results.image.width / results.image.height).toFixed(1);
        let ctx;
        if (aspectRatio === "1.3")
            ctx = fourThreeCtx;
        else if (aspectRatio === "1.8")
            ctx = sixteenNine;
        else {
            console.log("Not a handled aspect ratio");
            return
        }

        ctx.save();

        // canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        // ctx.drawImage(results.image, 0, 0, canvasElem.width, canvasElem.height, );
        if (results.multiFaceLandmarks) {
            for (const landmarks of results.multiFaceLandmarks) {

                // console.log(landmarks[168]);
                const {x, y, z} = landmarks[6];
                ctx.lineWidth = 1;
                ctx.fillStyle = 'rgba(0, 240, 0, 1)';
                drawPoint(ctx, x, y);
                // console.log(x*640,y*480,z*640);


                // drawConnectors(ctx, landmarks, FACEMESH_TESSELATION, {color: '#C0C0C070', lineWidth: 1});
                // drawConnectors(ctx, landmarks, FACEMESH_RIGHT_EYE, {color: '#FF3030'});
                // drawConnectors(ctx, landmarks, FACEMESH_RIGHT_EYEBROW, {color: '#FF3030'});
                // drawConnectors(ctx, landmarks, FACEMESH_RIGHT_IRIS, {color: '#FF3030'});
                // drawConnectors(ctx, landmarks, FACEMESH_LEFT_EYE, {color: '#30FF30'});
                // drawConnectors(ctx, landmarks, FACEMESH_LEFT_EYEBROW, {color: '#30FF30'});
                // drawConnectors(ctx, landmarks, FACEMESH_LEFT_IRIS, {color: '#30FF30'});
                // drawConnectors(ctx, landmarks, FACEMESH_FACE_OVAL, {color: '#E0E0E0'});
                // drawConnectors(ctx, landmarks, FACEMESH_LIPS, {color: '#E0E0E0'});

                // drawConnectors(ctx, landmarks, FACEMESH_FACE_OVAL, {color: '#FF3030', lineWidth: 1});

                /*
                const [midwayBetweenEyes] = results.multiFaceLandmarks.annotations.midwayBetweenEyes
                const x = midwayBetweenEyes[0];
                const y = midwayBetweenEyes[1];
                ctx.strokeStyle = 'rgba(200, 0, 0, 0.5)';
                ctx.setLineDash([1, 1]);
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(x, y , 10, 0, 2*Math.PI)
                ctx.stroke();
                ctx.lineWidth = 1;
                ctx.setLineDash([]);
                 */

                /*
                for(const points in landmarks){
                    console.log(landmarks[points]);
                    const {x,y} = landmarks[points];
                    drawPoint(x,y);
                }

                drawPoint(0.5, 0.5);

                 */

            }
        }
        else{
            console.log("no face landmarks", results);
        }
        ctx.restore();
    });

    stopBtn.onclick = () => {
        console.log("stopping");
        startBtn.enabled = false;
        stopBtn.enabled = false;
        stop = true;
    }

    startBtn.onclick = async () => {

        const parentDirectoryHandle = await window.showDirectoryPicker();
        // In that existing directory, create a new directory
        const directoryHandle = await parentDirectoryHandle.getDirectoryHandle('vch_images', {
            create: false,
        });
        console.log(`directory handle "${directoryHandle.name}" under "${parentDirectoryHandle.name}"`);

        let count = 0;

        // const offscreenCanvas = new OffscreenCanvas(1,1)

        for await (const [name, handle] of directoryHandle.entries()) {

            // if (count > 20) break;

            // console.log({ name, handle })
            const file = await handle.getFile();
            // console.log(file);

            // Check if the file is an image.
            if (file.type && !file.type.startsWith('image/')) {
                console.log('File is not an image.', file.type, file);
                return;
            }

            const reader = new FileReader();
            reader.addEventListener('load', async (event) => {
                count++;
                countSpan.innerText = count;

                const imgData = event.target.result;
                // tmpImg.src = imgData;
                // await tmpImg;

                const img = new Image();
                img.src = imgData;

                try {
                    await img.decode();
                    const aspectRatio = (img.naturalWidth / img.naturalHeight).toFixed(1);
                    // console.log(`${img.naturalWidth}wx${img.naturalHeight}h; ${aspectRatio}`)

                    if (aspectRatio === "1.3") {
                        // oneThreeDiv.appendChild(img);
                        await new Promise(resolve => setTimeout(resolve, 10));
                        await faceMesh.send({image: img});
                    } else if (aspectRatio === "1.8") {
                        // sixteenNineDiv.appendChild(img);
                        await new Promise(resolve => setTimeout(resolve, 10));
                        await faceMesh.send({image: img});
                    } else {
                        const logText = `file ${name} is size ${img.naturalWidth}wx${img.naturalHeight}h with unhandled aspect ratio: ${aspectRatio}`
                        console.log(logText);
                        otherRatioDiv.innerHTML = `<span>${otherRatioDiv.innerHTML}</span><br>`;
                    }
                    // otherRatioDiv.appendChild(img);


                } catch (err) {
                    console.error(`error on: ${name}`, err);
                    // stop = true;
                }

            });
            await reader.readAsDataURL(file);
            if (stop) break;

        }
        console.log("finished reading all files");
    }


</script>
</body>
</html>
