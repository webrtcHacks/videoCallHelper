<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>My speech</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        table {
            border: 1px solid;
        }

        div#chart {
            width: 80%;
            height: 300px;
            margin: auto;
        }
    </style>
</head>
<body>
<div id="chart" style=""></div>
<span id="output"></span>

<script src="events.json" type="application/json"></script>
<script>
    const localLevels = [];
    const remoteLevels = [];
    const trackEvents = [];
    let dupeCount = 0;

    /*
     *  Plotly setup
     */

    const chart = document.getElementById('chart');

    let localLevelsSeries = {
        x: [],
        y: [],
        type: 'histogram',
        name: 'local',
        opacity: 0.5,
        histfunc: "sum",
        autobinx: true,
    };

    let remoteLevelsSeries = {
        x: [],
        y: [],
        type: 'histogram',
        name: 'remote',
        opacity: 0.5,
        histfunc: "sum",
        autobinx: true

    };


    let layout = {
        grid: {rows: 2, columns: 1, pattern: 'independent'},
        xaxis: {
            autorange: true,
            fixedrange: false,
            showgrid: true,
            type: 'time'
        },
        yaxis: {
            autorange: true,
            showgrid: true,
            title: 'AudioLevels',
            range: [0],

        },
        barmode: 'overlay',
        margin: {t: 0}
    };


    async function main() {
        const response = await fetch("events.json");
        const events = await response.json();
        console.log("all", events.length);

        let lastEvent = {message: null, ts: null, data: null};
        events.forEach(event => {
            // Dedupe the same
            const lastEventDelta = Math.abs(event.ts - lastEvent.ts);
            const dataTheSame = JSON.stringify(event.data) === JSON.stringify(lastEvent.data);
            const dupe = event.message === lastEvent.message && dataTheSame && lastEventDelta < 100;
            lastEvent = event;
            if (dupe) {
                //console.log("repeat", lastEventDelta, event);
                dupeCount++;
                return
            }

            const datetime = new Date(event.ts).toLocaleTimeString();
            if (event.message === 'local_audio_level') {
                const audioLevelData = {timeString: datetime, ts: event.ts, level: event.data.audioLevel};
                localLevels.push(audioLevelData)
                // console.log(datetime, event.message, event.data.audioLevel)
            } else if (event.message === 'remote_audio_level') {
                const audioLevelData = {
                    timeString: datetime,
                    ts: event.ts,
                    level: event.data.audioLevel,
                    source: event.data.source
                };
                remoteLevels.push(audioLevelData)
                // console.log(datetime, event.message, event.data.audioLevel)
            } else {
                const eventData = {
                    timeString: datetime,
                    ts: event.ts,
                    message: event.message,
                    kind: event.data.kind || event.data?.trackData?.kind || null,
                    id: event.data.id || event.data?.trackData?.id || null
                }
                trackEvents.push(eventData)
                /*

                if(event.message === 'local_track_added' || event.message === 'remote_track_added' || event.message === 'gum_track_added'){
                    const {id, kind, label} = event.data.trackData;
                    const eventData = {time: datetime, message: event.message, kind: kind, id: id};
                    events.push(eventData)
                    // console.log(datetime, event.message, kind, label);
                }
                else{
                    const {id, kind, label, trackData} = event.data;
                    let eventData;
                    if(trackData){
                        eventData = {time: datetime, message: event.message, data: event.data.trackData};
                    } else
                        eventData = {time: datetime, message: event.message, data: event.data};
                    //events.push(eventData)

                }

                 */
            }
        });

        console.log("dupes", dupeCount);

        /*
        // Bin the data
        const timeStamps = events.map(event=>event.ts);
        const numberOfBins = 20

        const histGenerator = d3.bin()
            .domain([Math.min(...timeStamps),Math.max(...timeStamps)])
            .thresholds(numberOfBins);

        const bins = histGenerator(timeStamps);
        console.log(bins);

         */

        const localTimes = localLevels
            .filter((el, idx, arr) => arr[idx - 1] && el.timeString !== arr[idx - 1].timeString)
            .map(el => el.timeString);

        // ToDo: needs calibration
        const MIN_THRESHOLD = 0.05;
        const localValues = localLevels.map(e => e.level);
        const localThreshold = Math.max(...localValues) * MIN_THRESHOLD;

        // const localDisplayValues = localValues.map(level=>level>localThreshold);
        // console.log(localDisplayValues);

        // ToDo: turn this all into a class if it works
        async function getLevels(audioLevelArray = []){
            const returnArray = [];
            let lastSampleSpeaking = false;
            let sampleCount = 0;
            let lastStart = {};

            // Get thresholds based on the input
            const levels = audioLevelArray.map(e => e.level);
            const lowerThreshold = Math.max(...levels) * MIN_THRESHOLD;


            for(const value in audioLevelArray ){
                //audioLevelArray.forEach(value => {
                console.log(value);

                const {timeString, ts, level} = value;

                // console.log(timeString, level >= localThreshold);
                if (level >= lowerThreshold) {
                    // console.log("speaking");
                    sampleCount++;
                    if (!lastSampleSpeaking) {
                        lastStart = value;
                    }
                    lastSampleSpeaking = true;

                } else if (level < lowerThreshold) {
                    if (lastSampleSpeaking && sampleCount > 1) {
                        const interval = {
                            start: lastStart,
                            stop: value,
                            sampleCount: sampleCount
                        }

                        returnArray.push(interval);
                        console.log("start:", lastStart.timeString)
                        console.log("stop:", timeString)
                    }
                    sampleCount = 0;
                    lastSampleSpeaking = false;
                }

            }

            return returnArray;
        }

        const localSpeakingIntervals = getLevels(localLevels);

        // console.log(localSpeakingIntervals);

        // Doesn't work
        /*
        const myChart = TimelinesChart();
        const data = [{
            group: "local",
            data: localSpeakingIntervals.map(e=>{
                return {
                    timeRange:  [new Date(e.start.ts), new Date(e.stop.ts)],
                    val: 'speaking'
                }

            })
        }]

        console.log(data);
        myChart.data(data)(chart);
         */

        // https://stackoverflow.com/questions/44133677/plotly-create-horizontal-timeline
        const layout = {
            height: 300,
            yaxis: {
                showgrid: false,
                zeroline: false,
                showline: false,
                showticklabels: false
            },
           //  xaxis: {type: "time"}
        };


        /*
        Plotly.plot('chart', [{
            type: 'scatter',
            x: ["10:05:23 AM", "10:05:27 AM"],
            y: [1, 1],
            line: {width: 30},
        },
            {
                type: 'scatter',
                x: ["10:05:38 AM", "10:05:44 AM"],
                y: [1, 1],
                line: {width: 30},
            }

        ], layout)

         */


/*

        Plotly.plot('chart', [{
            type: 'bar',
            x: ["10:05:23 AM", "10:05:27 AM", "10:05:53 AM"],
            y: [0, 0, 0],
            // line: {width: 30},
            orientation: 'h',
            base: [4,26,0]

        }], {xaxis:{type:"time"}})


 */


    }

    main();

</script>
</body>
</html>
